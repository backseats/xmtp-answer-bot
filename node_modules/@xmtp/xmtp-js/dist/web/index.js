import { utils } from 'ethers';
import kn from 'long';
import { keystore, authn, signature, publicKey, ciphertext, privateKey, message, content, messageApi, contact, invitation, composite, fetcher } from '@xmtp/proto';
import * as H from '@noble/secp256k1';
import { Mutex } from 'async-mutex';
import to from 'elliptic';

var Yi=Object.create;var En=Object.defineProperty;var Zi=Object.getOwnPropertyDescriptor;var es=Object.getOwnPropertyNames;var ts=Object.getPrototypeOf,rs=Object.prototype.hasOwnProperty;var Sn=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var ns=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let i of es(e))!rs.call(n,i)&&i!==t&&En(n,i,{get:()=>e[i],enumerable:!(r=Zi(e,i))||r.enumerable});return n};var xn=(n,e,t)=>(t=n!=null?Yi(ts(n)):{},ns(e||!n||!n.__esModule?En(t,"default",{value:n,enumerable:!0}):t,n));var On=Sn((aa,Nn)=>{Nn.exports={webcrypto:window.crypto};});var ui=Sn((Tp,Ir)=>{(function(){var n="input is invalid type",e="finalize already called",t=typeof window=="object",r=t?window:{};r.JS_SHA3_NO_WINDOW&&(t=!1);var i=!t&&typeof self=="object",o=!r.JS_SHA3_NO_NODE_JS&&typeof process=="object"&&process.versions&&process.versions.node;o?r=global:i&&(r=self);var a=!r.JS_SHA3_NO_COMMON_JS&&typeof Ir=="object"&&Ir.exports,c=typeof define=="function"&&define.amd,p=!r.JS_SHA3_NO_ARRAY_BUFFER&&typeof ArrayBuffer<"u",l="0123456789abcdef".split(""),g=[31,7936,2031616,520093696],b=[4,1024,262144,67108864],C=[1,256,65536,16777216],ie=[6,1536,393216,100663296],R=[0,8,16,24],Pe=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],it=[224,256,384,512],We=[128,256],gn=["hex","buffer","arrayBuffer","array","digest"],vn={128:168,256:136};(r.JS_SHA3_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(s){return Object.prototype.toString.call(s)==="[object Array]"}),p&&(r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(s){return typeof s=="object"&&s.buffer&&s.buffer.constructor===ArrayBuffer});for(var wn=function(s,d,u){return function(y){return new k(s,d,s).update(y)[u]()}},bn=function(s,d,u){return function(y,m){return new k(s,d,m).update(y)[u]()}},Pn=function(s,d,u){return function(y,m,h,v){return fe["cshake"+s].update(y,m,h,v)[u]()}},Cn=function(s,d,u){return function(y,m,h,v){return fe["kmac"+s].update(y,m,h,v)[u]()}},Pt=function(s,d,u,y){for(var m=0;m<gn.length;++m){var h=gn[m];s[h]=d(u,y,h);}return s},Kn=function(s,d){var u=wn(s,d,"hex");return u.create=function(){return new k(s,d,s)},u.update=function(y){return u.create().update(y)},Pt(u,wn,s,d)},zi=function(s,d){var u=bn(s,d,"hex");return u.create=function(y){return new k(s,d,y)},u.update=function(y,m){return u.create(m).update(y)},Pt(u,bn,s,d)},$i=function(s,d){var u=vn[s],y=Pn(s,d,"hex");return y.create=function(m,h,v){return !h&&!v?fe["shake"+s].create(m):new k(s,d,m).bytepad([h,v],u)},y.update=function(m,h,v,f){return y.create(h,v,f).update(m)},Pt(y,Pn,s,d)},Qi=function(s,d){var u=vn[s],y=Cn(s,d,"hex");return y.create=function(m,h,v){return new Lr(s,d,h).bytepad(["KMAC",v],u).bytepad([m],u)},y.update=function(m,h,v,f){return y.create(m,v,f).update(h)},Pt(y,Cn,s,d)},An=[{name:"keccak",padding:C,bits:it,createMethod:Kn},{name:"sha3",padding:ie,bits:it,createMethod:Kn},{name:"shake",padding:g,bits:We,createMethod:zi},{name:"cshake",padding:b,bits:We,createMethod:$i},{name:"kmac",padding:b,bits:We,createMethod:Qi}],fe={},st=[],Ce=0;Ce<An.length;++Ce)for(var je=An[Ce],Ct=je.bits,ot=0;ot<Ct.length;++ot){var qr=je.name+"_"+Ct[ot];if(st.push(qr),fe[qr]=je.createMethod(Ct[ot],je.padding),je.name!=="sha3"){var Tn=je.name+Ct[ot];st.push(Tn),fe[Tn]=fe[qr];}}function k(s,d,u){this.blocks=[],this.s=[],this.padding=d,this.outputBits=u,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(s<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=u>>5,this.extraBytes=(u&31)>>3;for(var y=0;y<50;++y)this.s[y]=0;}k.prototype.update=function(s){if(this.finalized)throw new Error(e);var d,u=typeof s;if(u!=="string"){if(u==="object"){if(s===null)throw new Error(n);if(p&&s.constructor===ArrayBuffer)s=new Uint8Array(s);else if(!Array.isArray(s)&&(!p||!ArrayBuffer.isView(s)))throw new Error(n)}else throw new Error(n);d=!0;}for(var y=this.blocks,m=this.byteCount,h=s.length,v=this.blockCount,f=0,B=this.s,w,T;f<h;){if(this.reset)for(this.reset=!1,y[0]=this.block,w=1;w<v+1;++w)y[w]=0;if(d)for(w=this.start;f<h&&w<m;++f)y[w>>2]|=s[f]<<R[w++&3];else for(w=this.start;f<h&&w<m;++f)T=s.charCodeAt(f),T<128?y[w>>2]|=T<<R[w++&3]:T<2048?(y[w>>2]|=(192|T>>6)<<R[w++&3],y[w>>2]|=(128|T&63)<<R[w++&3]):T<55296||T>=57344?(y[w>>2]|=(224|T>>12)<<R[w++&3],y[w>>2]|=(128|T>>6&63)<<R[w++&3],y[w>>2]|=(128|T&63)<<R[w++&3]):(T=65536+((T&1023)<<10|s.charCodeAt(++f)&1023),y[w>>2]|=(240|T>>18)<<R[w++&3],y[w>>2]|=(128|T>>12&63)<<R[w++&3],y[w>>2]|=(128|T>>6&63)<<R[w++&3],y[w>>2]|=(128|T&63)<<R[w++&3]);if(this.lastByteIndex=w,w>=m){for(this.start=w-m,this.block=y[v],w=0;w<v;++w)B[w]^=y[w];at(B),this.reset=!0;}else this.start=w;}return this},k.prototype.encode=function(s,d){var u=s&255,y=1,m=[u];for(s=s>>8,u=s&255;u>0;)m.unshift(u),s=s>>8,u=s&255,++y;return d?m.push(y):m.unshift(y),this.update(m),m.length},k.prototype.encodeString=function(s){var d,u=typeof s;if(u!=="string"){if(u==="object"){if(s===null)throw new Error(n);if(p&&s.constructor===ArrayBuffer)s=new Uint8Array(s);else if(!Array.isArray(s)&&(!p||!ArrayBuffer.isView(s)))throw new Error(n)}else throw new Error(n);d=!0;}var y=0,m=s.length;if(d)y=m;else for(var h=0;h<s.length;++h){var v=s.charCodeAt(h);v<128?y+=1:v<2048?y+=2:v<55296||v>=57344?y+=3:(v=65536+((v&1023)<<10|s.charCodeAt(++h)&1023),y+=4);}return y+=this.encode(y*8),this.update(s),y},k.prototype.bytepad=function(s,d){for(var u=this.encode(d),y=0;y<s.length;++y)u+=this.encodeString(s[y]);var m=d-u%d,h=[];return h.length=m,this.update(h),this},k.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var s=this.blocks,d=this.lastByteIndex,u=this.blockCount,y=this.s;if(s[d>>2]|=this.padding[d&3],this.lastByteIndex===this.byteCount)for(s[0]=s[u],d=1;d<u+1;++d)s[d]=0;for(s[u-1]|=2147483648,d=0;d<u;++d)y[d]^=s[d];at(y);}},k.prototype.toString=k.prototype.hex=function(){this.finalize();for(var s=this.blockCount,d=this.s,u=this.outputBlocks,y=this.extraBytes,m=0,h=0,v="",f;h<u;){for(m=0;m<s&&h<u;++m,++h)f=d[m],v+=l[f>>4&15]+l[f&15]+l[f>>12&15]+l[f>>8&15]+l[f>>20&15]+l[f>>16&15]+l[f>>28&15]+l[f>>24&15];h%s===0&&(at(d),m=0);}return y&&(f=d[m],v+=l[f>>4&15]+l[f&15],y>1&&(v+=l[f>>12&15]+l[f>>8&15]),y>2&&(v+=l[f>>20&15]+l[f>>16&15])),v},k.prototype.arrayBuffer=function(){this.finalize();var s=this.blockCount,d=this.s,u=this.outputBlocks,y=this.extraBytes,m=0,h=0,v=this.outputBits>>3,f;y?f=new ArrayBuffer(u+1<<2):f=new ArrayBuffer(v);for(var B=new Uint32Array(f);h<u;){for(m=0;m<s&&h<u;++m,++h)B[h]=d[m];h%s===0&&at(d);}return y&&(B[m]=d[m],f=f.slice(0,v)),f},k.prototype.buffer=k.prototype.arrayBuffer,k.prototype.digest=k.prototype.array=function(){this.finalize();for(var s=this.blockCount,d=this.s,u=this.outputBlocks,y=this.extraBytes,m=0,h=0,v=[],f,B;h<u;){for(m=0;m<s&&h<u;++m,++h)f=h<<2,B=d[m],v[f]=B&255,v[f+1]=B>>8&255,v[f+2]=B>>16&255,v[f+3]=B>>24&255;h%s===0&&at(d);}return y&&(f=h<<2,B=d[m],v[f]=B&255,y>1&&(v[f+1]=B>>8&255),y>2&&(v[f+2]=B>>16&255)),v};function Lr(s,d,u){k.call(this,s,d,u);}Lr.prototype=new k,Lr.prototype.finalize=function(){return this.encode(this.outputBits,!0),k.prototype.finalize.call(this)};var at=function(s){var d,u,y,m,h,v,f,B,w,T,Kt,At,Tt,Et,St,xt,kt,Bt,Mt,Rt,Dt,It,Ut,Vt,Nt,Ot,_t,qt,Lt,Ft,Ht,Gt,Jt,Wt,jt,Xt,zt,$t,Qt,Yt,Zt,er,tr,rr,nr,ir,sr,or,ar,cr,pr,dr,ur,yr,lr,mr,fr,hr,gr,vr,wr,br,Pr;for(y=0;y<48;y+=2)m=s[0]^s[10]^s[20]^s[30]^s[40],h=s[1]^s[11]^s[21]^s[31]^s[41],v=s[2]^s[12]^s[22]^s[32]^s[42],f=s[3]^s[13]^s[23]^s[33]^s[43],B=s[4]^s[14]^s[24]^s[34]^s[44],w=s[5]^s[15]^s[25]^s[35]^s[45],T=s[6]^s[16]^s[26]^s[36]^s[46],Kt=s[7]^s[17]^s[27]^s[37]^s[47],At=s[8]^s[18]^s[28]^s[38]^s[48],Tt=s[9]^s[19]^s[29]^s[39]^s[49],d=At^(v<<1|f>>>31),u=Tt^(f<<1|v>>>31),s[0]^=d,s[1]^=u,s[10]^=d,s[11]^=u,s[20]^=d,s[21]^=u,s[30]^=d,s[31]^=u,s[40]^=d,s[41]^=u,d=m^(B<<1|w>>>31),u=h^(w<<1|B>>>31),s[2]^=d,s[3]^=u,s[12]^=d,s[13]^=u,s[22]^=d,s[23]^=u,s[32]^=d,s[33]^=u,s[42]^=d,s[43]^=u,d=v^(T<<1|Kt>>>31),u=f^(Kt<<1|T>>>31),s[4]^=d,s[5]^=u,s[14]^=d,s[15]^=u,s[24]^=d,s[25]^=u,s[34]^=d,s[35]^=u,s[44]^=d,s[45]^=u,d=B^(At<<1|Tt>>>31),u=w^(Tt<<1|At>>>31),s[6]^=d,s[7]^=u,s[16]^=d,s[17]^=u,s[26]^=d,s[27]^=u,s[36]^=d,s[37]^=u,s[46]^=d,s[47]^=u,d=T^(m<<1|h>>>31),u=Kt^(h<<1|m>>>31),s[8]^=d,s[9]^=u,s[18]^=d,s[19]^=u,s[28]^=d,s[29]^=u,s[38]^=d,s[39]^=u,s[48]^=d,s[49]^=u,Et=s[0],St=s[1],ir=s[11]<<4|s[10]>>>28,sr=s[10]<<4|s[11]>>>28,qt=s[20]<<3|s[21]>>>29,Lt=s[21]<<3|s[20]>>>29,vr=s[31]<<9|s[30]>>>23,wr=s[30]<<9|s[31]>>>23,er=s[40]<<18|s[41]>>>14,tr=s[41]<<18|s[40]>>>14,Wt=s[2]<<1|s[3]>>>31,jt=s[3]<<1|s[2]>>>31,xt=s[13]<<12|s[12]>>>20,kt=s[12]<<12|s[13]>>>20,or=s[22]<<10|s[23]>>>22,ar=s[23]<<10|s[22]>>>22,Ft=s[33]<<13|s[32]>>>19,Ht=s[32]<<13|s[33]>>>19,br=s[42]<<2|s[43]>>>30,Pr=s[43]<<2|s[42]>>>30,yr=s[5]<<30|s[4]>>>2,lr=s[4]<<30|s[5]>>>2,Xt=s[14]<<6|s[15]>>>26,zt=s[15]<<6|s[14]>>>26,Bt=s[25]<<11|s[24]>>>21,Mt=s[24]<<11|s[25]>>>21,cr=s[34]<<15|s[35]>>>17,pr=s[35]<<15|s[34]>>>17,Gt=s[45]<<29|s[44]>>>3,Jt=s[44]<<29|s[45]>>>3,Vt=s[6]<<28|s[7]>>>4,Nt=s[7]<<28|s[6]>>>4,mr=s[17]<<23|s[16]>>>9,fr=s[16]<<23|s[17]>>>9,$t=s[26]<<25|s[27]>>>7,Qt=s[27]<<25|s[26]>>>7,Rt=s[36]<<21|s[37]>>>11,Dt=s[37]<<21|s[36]>>>11,dr=s[47]<<24|s[46]>>>8,ur=s[46]<<24|s[47]>>>8,rr=s[8]<<27|s[9]>>>5,nr=s[9]<<27|s[8]>>>5,Ot=s[18]<<20|s[19]>>>12,_t=s[19]<<20|s[18]>>>12,hr=s[29]<<7|s[28]>>>25,gr=s[28]<<7|s[29]>>>25,Yt=s[38]<<8|s[39]>>>24,Zt=s[39]<<8|s[38]>>>24,It=s[48]<<14|s[49]>>>18,Ut=s[49]<<14|s[48]>>>18,s[0]=Et^~xt&Bt,s[1]=St^~kt&Mt,s[10]=Vt^~Ot&qt,s[11]=Nt^~_t&Lt,s[20]=Wt^~Xt&$t,s[21]=jt^~zt&Qt,s[30]=rr^~ir&or,s[31]=nr^~sr&ar,s[40]=yr^~mr&hr,s[41]=lr^~fr&gr,s[2]=xt^~Bt&Rt,s[3]=kt^~Mt&Dt,s[12]=Ot^~qt&Ft,s[13]=_t^~Lt&Ht,s[22]=Xt^~$t&Yt,s[23]=zt^~Qt&Zt,s[32]=ir^~or&cr,s[33]=sr^~ar&pr,s[42]=mr^~hr&vr,s[43]=fr^~gr&wr,s[4]=Bt^~Rt&It,s[5]=Mt^~Dt&Ut,s[14]=qt^~Ft&Gt,s[15]=Lt^~Ht&Jt,s[24]=$t^~Yt&er,s[25]=Qt^~Zt&tr,s[34]=or^~cr&dr,s[35]=ar^~pr&ur,s[44]=hr^~vr&br,s[45]=gr^~wr&Pr,s[6]=Rt^~It&Et,s[7]=Dt^~Ut&St,s[16]=Ft^~Gt&Vt,s[17]=Ht^~Jt&Nt,s[26]=Yt^~er&Wt,s[27]=Zt^~tr&jt,s[36]=cr^~dr&rr,s[37]=pr^~ur&nr,s[46]=vr^~br&yr,s[47]=wr^~Pr&lr,s[8]=It^~Et&xt,s[9]=Ut^~St&kt,s[18]=Gt^~Vt&Ot,s[19]=Jt^~Nt&_t,s[28]=er^~Wt&Xt,s[29]=tr^~jt&zt,s[38]=dr^~rr&ir,s[39]=ur^~nr&sr,s[48]=br^~yr&mr,s[49]=Pr^~lr&fr,s[0]^=Pe[y],s[1]^=Pe[y+1];};if(a)Ir.exports=fe;else {for(Ce=0;Ce<st.length;++Ce)r[st[Ce]]=fe[st[Ce]];c&&define(function(){return fe});}})();});var Re=n=>`/xmtp/0/${n}/proto`,se=(n,e)=>{let t=[utils.getAddress(n),utils.getAddress(e)];return t.sort(),Re(`dm-${t.join("-")}`)},pt=n=>Re(`m-${n}`),dt=n=>Re(`contact-${utils.getAddress(n)}`),de=n=>Re(`intro-${utils.getAddress(n)}`),Ke=n=>Re(`invite-${utils.getAddress(n)}`),Fr=n=>Re(`privatestore-${n}`);var Cr=n=>new Promise(e=>setTimeout(e,n));var is=n=>!!n;async function Xe(n,e,t,r,i=is,o=1){let a=typeof o=="number"?o:1;try{return await n(...e)}catch(c){if(!i(c)||a>t)throw c;return await Cr(r),Xe(n,e,t,r,i,a+1)}}async function*Hr(n,e){for await(let t of n){let r=await Promise.allSettled(t.map(e)),i=[];for(let o of r)o.status==="fulfilled"?i.push(o.value):console.warn("Failed to process envelope due to reason: ",o.reason);yield i;}}function D(n){return kn.fromNumber(n.valueOf()).multiply(1e6)}function _(n){return new Date(n.divide(1e6).toNumber())}var ue=n=>n&&D(n).toString(),ss=n=>{if(n)return _(kn.fromString(n))};var{b64Decode:Kr,b64Encode:Bn}=fetcher;function Gr(n,e){let t=new Uint8Array(n.length+e.length);return t.set(n),t.set(e,n.length),t}function Mn(n){let e=new ArrayBuffer(4);return new DataView(e).setInt32(0,n,!0),new Uint8Array(e)}function Rn(n){let e=n.buffer;return new DataView(e).getInt32(0,!0)}var Dn=()=>typeof window<"u"&&typeof window.document<"u";function Ar(n){let[e,t,...r]=n.split(".");return {major:Number(e),minor:Number(t),patch:r.join(".")}}function In(n,e){return !n||!e?!0:Ar(n).major===Ar(e).major}function Un(n,e){if(!n||!e)return !1;let t=Ar(n),r=Ar(e);return t.major!==r.major?t.major>r.major:t.minor!==r.minor?t.minor>r.minor:!t.patch||!r.patch?!1:as(t.patch,r.patch)}function as(n,e){let[t,r]=n.split("-"),[i,o]=e.split("-");if(Number(t)!==Number(i))return Number(t)>Number(i);if(!r||!o)return !1;let[a,c]=r.split("."),[p,l]=o.split(".");return a!==p?!0:Number(c)>Number(l)}function Jr(n){if(!n)return null;if(cs(n))return ps(n);if(typeof n.getAddress!="function")throw new Error("Unknown wallet type");return n}function cs(n){return "type"in n&&n.type==="walletClient"}function ps(n){let{account:e}=n;if(!e||!e.address)throw new Error("WalletClient is not configured");return {getAddress:async()=>e.address,signMessage:async t=>await n.signMessage({message:t,account:e})}}var F=class{topics;client;messages;resolvers;callback;subscriptionManager;onConnectionLost;constructor(e,t,r,i,o){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(r,i),this.onConnectionLost=o;}newMessageCallback(e,t){return async r=>{if(r.message)try{let i=await e(r);if(!i)return;if(t){let a=t(i);a&&this.resubscribeToTopics(a);}let o=this.resolvers.pop();o?o({value:i}):this.messages.unshift(i);}catch(i){console.warn(i);}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},async e=>{this.callback&&await this?.callback(e);},this.onConnectionLost);}static async create(e,t,r,i,o){let a=new F(e,t,r,i,o);return await a.start(),a}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach(e=>e({value:void 0,done:!0})),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){let e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise(t=>this.resolvers.unshift(t)):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if(typeof this.subscriptionManager?.updateContentTopics=="function")return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},async t=>{this.callback&&await this?.callback(t);},this.onConnectionLost);}};var Wr=32,jr=12,ds=16,I=class{aes256GcmHkdfSha256;constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<ds)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(e.aes256GcmHkdfSha256.hkdfSalt.length!==Wr)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(e.aes256GcmHkdfSha256.gcmNonce.length!==jr)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256;}toBytes(){return ciphertext.Ciphertext.encode(this).finish()}static fromBytes(e){return new I(ciphertext.Ciphertext.decode(e))}};var _n=xn(On(),1),us=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0,ys=us??_n.webcrypto,M=ys;var ls=new ArrayBuffer(0);async function U(n){return new Uint8Array(await M.subtle.digest("SHA-256",n))}async function ee(n,e,t){let r=M.getRandomValues(new Uint8Array(Wr)),i=M.getRandomValues(new Uint8Array(jr)),o=await Ln(e,r),a=await M.subtle.encrypt(qn(i,t),o,n);return new I({aes256GcmHkdfSha256:{payload:new Uint8Array(a),hkdfSalt:r,gcmNonce:i}})}async function j(n,e,t){if(!n.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");let r=await Ln(e,n.aes256GcmHkdfSha256.hkdfSalt),i=await M.subtle.decrypt(qn(n.aes256GcmHkdfSha256.gcmNonce,t),r,n.aes256GcmHkdfSha256.payload);return new Uint8Array(i)}function qn(n,e){let t={name:"AES-GCM",iv:n};return e&&(t.additionalData=e),t}async function Ln(n,e){let t=await M.subtle.importKey("raw",n,"HKDF",!1,["deriveKey"]);return M.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:e,info:ls},t,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}var X=H.utils.bytesToHex;function z(n){n.startsWith("0x")&&(n=n.slice(2));let e=new Uint8Array(n.length/2);for(let t=0;t<e.length;t++){let r=t*2;e[t]=Number.parseInt(n.slice(r,r+2),16);}return e}function Ae(n,e){if(n.length!==e.length)return !1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return !1;return !0}function Gn(n){if(n.bytes.length!==32)throw new Error(`invalid private key length: ${n.bytes.length}`)}var O=class{createdNs;secp256k1;publicKey;constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(Gn(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new E(e.publicKey);}static async generate(e){let t={bytes:H.utils.randomPrivateKey()},r=kn.fromNumber(new Date().getTime()).mul(1e6),i=new re({secp256k1Uncompressed:{bytes:H.getPublicKey(t.bytes)},createdNs:r}),o=await e.signKey(i);return new O({secp256k1:t,createdNs:r,publicKey:o})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){let[t,r]=await H.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new S({ecdsaCompact:{bytes:t,recovery:r}})}async signKey(e){let t=e.toBytes(),r=await U(t),i=await this.sign(r);return new E({keyBytes:t,signature:i})}static async signerKey(e,t){let r=await U(e.bytesToSign());return Xr(r,t)}sharedSecret(e){return H.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,r){let i=this.sharedSecret(t);return ee(e,i,r)}decrypt(e,t,r){let i=this.sharedSecret(t);return j(e,i,r)}matches(e){return this.publicKey.equals(e)}equals(e){return Ae(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return privateKey.SignedPrivateKey.encode(this).finish()}validatePublicKey(){let e=H.getPublicKey(this.secp256k1.bytes);return Ae(e,this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new O(privateKey.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new O({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:E.fromLegacyKey(e.publicKey,t)})}},te=class{timestamp;secp256k1;publicKey;constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(Gn(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new V(e.publicKey);}static generate(){let e={bytes:H.utils.randomPrivateKey()},t=kn.fromNumber(new Date().getTime());return new te({secp256k1:e,timestamp:t,publicKey:new V({secp256k1Uncompressed:{bytes:H.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){let[t,r]=await H.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new S({ecdsaCompact:{bytes:t,recovery:r}})}async signKey(e){let t=await U(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return H.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,r){let i=this.sharedSecret(t);return ee(e,i,r)}decrypt(e,t,r){let i=this.sharedSecret(t);return j(e,i,r)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){let e=H.getPublicKey(this.secp256k1.bytes);return Ae(e,this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return privateKey.PrivateKey.encode(this).finish()}static fromBytes(e){return new te(privateKey.PrivateKey.decode(e))}};function jn(n){if(n.bytes.length!==64)throw new Error(`invalid signature length: ${n.bytes.length}`);if(n.recovery!==0&&n.recovery!==1)throw new Error(`invalid recovery bit: ${n.recovery}`)}function Xn(n,e){return n.recovery===e.recovery&&Ae(n.bytes,e.bytes)}function Xr(n,e){let t=H.recoverPublicKey(n,e.bytes,e.recovery);return t?new re({secp256k1Uncompressed:{bytes:t},createdNs:kn.fromNumber(0)}):void 0}var S=class{ecdsaCompact;walletEcdsaCompact;constructor(e){if(e.ecdsaCompact)jn(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else if(e.walletEcdsaCompact)jn(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact;else throw new Error("invalid signature")}async signerKey(e){return this.ecdsaCompact?O.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?oe.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=H.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else if(this.walletEcdsaCompact)t=H.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery);else throw new Error("invalid v1 signature");return t?new V({secp256k1Uncompressed:{bytes:t},timestamp:kn.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Xn(this.ecdsaCompact,e.ecdsaCompact):this.walletEcdsaCompact&&e.walletEcdsaCompact?Xn(this.walletEcdsaCompact,e.walletEcdsaCompact):!1}toBytes(){return signature.Signature.encode(this).finish()}static fromBytes(e){return new S(signature.Signature.decode(e))}};var oe=class{wallet;constructor(e){this.wallet=e;}static identitySigRequestText(e){return `XMTP : Create Identity
${X(e)}

For more info: https://xmtp.org/signatures/`}static signerKey(e,t){let r=z(utils.hashMessage(this.identitySigRequestText(e.bytesToSign())));return Xr(r,t)}async signKey(e){let t=e.toBytes(),r=await this.wallet.signMessage(oe.identitySigRequestText(t)),i=utils.splitSignature(r),o=z(i.r),a=z(i.s),c=new Uint8Array(64);c.set(o),c.set(a,o.length);let p=new S({walletEcdsaCompact:{bytes:c,recovery:i.recoveryParam}});return new E({keyBytes:t,signature:p})}};function hs(n){if(n.bytes.length!==65)throw new Error(`invalid public key length: ${n.bytes.length}`);if(n.bytes[0]!==4)throw new Error(`unrecognized public key prefix: ${n.bytes[0]}`)}var gs=new kn(10**9).mul(10**9),re=class{createdNs;secp256k1Uncompressed;constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");hs(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned();}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(gs)}get timestamp(){return (this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return e.ecdsaCompact?H.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes):!1}async verifyKey(e){if(!e.signature)return !1;let t=await U(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return Ae(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return utils.computeAddress(this.secp256k1Uncompressed.bytes)}toBytes(){return publicKey.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new re(publicKey.UnsignedPublicKey.decode(e))}},E=class extends re{keyBytes;signature;constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(publicKey.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new S(e.signature);}get unsignedKey(){return new re({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");let e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return publicKey.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new E(publicKey.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new S({ecdsaCompact:e.walletEcdsaCompact})),new V({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let r=e.signature;return t&&(r=new S({walletEcdsaCompact:r.ecdsaCompact})),new E({keyBytes:e.bytesToSign(),signature:r})}},V=class extends re{signature;constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new S({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new S(e.signature));}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return publicKey.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){let t=await e.signMessage(oe.identitySigRequestText(this.bytesToSign())),r=utils.splitSignature(t),i=z(r.r),o=z(r.s),a=new Uint8Array(64);a.set(i),a.set(o,i.length),this.signature=new S({ecdsaCompact:{bytes:a,recovery:r.recoveryParam}});}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");let e=z(utils.hashMessage(oe.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return publicKey.PublicKey.encode(this).finish()}static fromBytes(e){return new V(publicKey.PublicKey.decode(e))}};var A=class{identityKey;preKey;constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new E(e.identityKey),this.preKey=new E(e.preKey);}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return publicKey.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new P({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){let t=publicKey.SignedPublicKeyBundle.decode(e);return new A(t)}static fromLegacyBundle(e){return new A({identityKey:E.fromLegacyKey(e.identityKey,!0),preKey:E.fromLegacyKey(e.preKey)})}},P=class{identityKey;preKey;constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new V(e.identityKey),this.preKey=new V(e.preKey);}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return publicKey.PublicKeyBundle.encode(this).finish()}static fromBytes(e){let t=publicKey.PublicKeyBundle.decode(e);return new P(t)}};var ut=class extends Error{constructor(e){super(`no pre-key matches: ${X(e.secp256k1Uncompressed.bytes)}`);}};var G=class{identityKey;preKeys;version=2;_publicKeyBundle;constructor(e){if(!e.identityKey)throw new Error("missing identity key");this.identityKey=new O(e.identityKey),this.preKeys=(e.preKeys||[]).map(t=>new O(t));}static async generate(e){let t=await O.generate(new oe(e)),r=new G({identityKey:t,preKeys:[]});return await r.addPreKey(),r}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){let t=this.preKeys.find(r=>r.matches(e));if(!t)throw new ut(e);return t}async addPreKey(){this._publicKeyBundle=void 0;let e=await O.generate(this.identityKey);this.preKeys.unshift(e);}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new A({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,r){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let i,o,a;r?(a=this.findPreKey(t),i=a.sharedSecret(e.identityKey),o=this.identityKey.sharedSecret(e.preKey)):(a=this.findPreKey(t),i=this.identityKey.sharedSecret(e.preKey),o=a.sharedSecret(e.identityKey));let c=a.sharedSecret(e.preKey),p=new Uint8Array(i.length+o.length+c.length);return p.set(i,0),p.set(o,i.length),p.set(c,i.length+o.length),p}encode(){return privateKey.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return this.identityKey.validatePublicKey()?this.preKeys.every(e=>e.validatePublicKey()):!1}equals(e){if(this.preKeys.length!==e.preKeys.length)return !1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return !1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new G({identityKey:O.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map(t=>O.fromLegacyKey(t))})}},N=class{identityKey;preKeys;version=1;_publicKeyBundle;constructor(e){if(!e.identityKey)throw new Error("missing identity key");this.identityKey=new te(e.identityKey),this.preKeys=(e.preKeys||[]).map(t=>new te(t));}static async generate(e){let t=te.generate();e&&await t.publicKey.signWithWallet(e);let r=new N({identityKey:t,preKeys:[]});return await r.addPreKey(),r}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){let t=this.preKeys.find(r=>r.matches(e));if(!t)throw new ut(e);return t}async addPreKey(){this._publicKeyBundle=void 0;let e=te.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e);}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new P({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return this.identityKey.validatePublicKey()?this.preKeys.every(e=>e.validatePublicKey()):!1}async sharedSecret(e,t,r){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let i,o,a;r?(a=this.findPreKey(t),i=a.sharedSecret(e.identityKey),o=this.identityKey.sharedSecret(e.preKey)):(a=this.findPreKey(t),i=this.identityKey.sharedSecret(e.preKey),o=a.sharedSecret(e.identityKey));let c=a.sharedSecret(e.preKey),p=new Uint8Array(i.length+o.length+c.length);return p.set(i,0),p.set(o,i.length),p.set(c,i.length+o.length),p}encode(){return privateKey.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}};function De(n){let e=privateKey.PrivateKeyBundle.decode(n);if(e.v1)return new N(e.v1);if(e.v2)return new G(e.v2);throw new Error("unknown private key bundle version")}var vs=16,ws=65,bs=32,Ps=16,Cs=n=>{if(n.iv.length!==vs)throw new Error("Invalid iv length");if(n.ephemeralPublicKey.length!==ws)throw new Error("Invalid ephemPublicKey length");if(n.ciphertext.length<1||n.ciphertext.length%Ps!==0)throw new Error("Invalid ciphertext length");if(n.mac.length!==bs)throw new Error("Invalid mac length")},ye=class{eciesBytes;signature;ciphertext;constructor({eciesBytes:e,signature:t}){if(!e||!e.length)throw new Error("eciesBytes is empty");if(!t)throw new Error("signature is undefined");this.eciesBytes=e,this.signature=new S(t),this.ciphertext=ciphertext.SignedEciesCiphertext_Ecies.decode(e);}toBytes(){return ciphertext.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await U(this.eciesBytes))}static fromBytes(e){let t=ciphertext.SignedEciesCiphertext.decode(e);return new ye(t)}static async create(e,t){Cs(e);let r=ciphertext.SignedEciesCiphertext_Ecies.encode(e).finish(),i=await t.sign(await U(r));return new ye({eciesBytes:r,signature:i})}};var yt=class{messageEnvelope;onSend;constructor(e,t){this.messageEnvelope=e,this.onSend=t;}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return X(await U(this.messageEnvelope.message))}async send(){await this.onSend();}};var K=class extends Error{code;constructor(e,t){super(t),this.code=e;}};var Ie=n=>{if(n.error)throw new K(n.error.code,n.error.message);if(!n.result)throw new K(keystore.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in n.result&&!n.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in n.result&&!n.result.decrypted)throw new Error("Missing decrypted result");return n.result},kr=(n,e)=>({requests:n.map(t=>{let r=new P({identityKey:t.header.sender?.identityKey,preKey:t.header.sender?.preKey}),i=e.equals(r);return {payload:t.ciphertext,peerKeys:i?new P({identityKey:t.header.recipient?.identityKey,preKey:t.header.recipient?.preKey}):r,headerBytes:t.headerBytes,isSender:i}})});var $=class{authorityId;typeId;versionMajor;versionMinor;constructor(e){this.authorityId=e.authorityId,this.typeId=e.typeId,this.versionMajor=e.versionMajor,this.versionMinor=e.versionMinor;}toString(){return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`}static fromString(e){let[t,r]=e.split(":"),[i,o]=t.split("/"),[a,c]=r.split(".");return new $({authorityId:i,typeId:o,versionMajor:Number(a),versionMinor:Number(c)})}sameAs(e){return this.authorityId===e.authorityId&&this.typeId===e.typeId}},As=new $({authorityId:"xmtp.org",typeId:"fallback",versionMajor:1,versionMinor:0});var Ee=new $({authorityId:"xmtp.org",typeId:"text",versionMajor:1,versionMinor:0});var lt=class{get contentType(){return Ee}encode(e){return {type:Ee,parameters:{encoding:"UTF-8"},content:new TextEncoder().encode(e)}}decode(e){let t=e.parameters.encoding;if(t&&t!=="UTF-8")throw new Error(`unrecognized encoding ${t}`);return new TextDecoder().decode(e.content)}fallback(e){}};var Q=class{conversationVersion="v1";peerAddress;createdAt;context=void 0;client;constructor(e,t,r){this.peerAddress=utils.getAddress(t),this.client=e,this.createdAt=r;}get clientAddress(){return this.client.address}get topic(){return se(this.peerAddress,this.client.address)}get ephemeralTopic(){return se(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){let t=se(this.peerAddress,this.client.address),r=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(r,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");let t=await this.processEnvelope(e),r=await this.decryptBatch([t],e.contentTopic,!0);if(!r.length)throw new Error("No results");return r[0]}async prepareMessage(e,t){let r,i=await this.client.getUserContact(this.peerAddress);if(!i)throw new Error(`recipient ${this.peerAddress} is not registered`);i instanceof P||(i=i.toLegacyBundle()),this.client.contacts.has(this.peerAddress)?r=[this.topic]:(r=[de(this.peerAddress),de(this.client.address),this.topic],this.client.contacts.add(this.peerAddress));let o=await this.client.encodeContent(e,t),a=await this.createMessage(o,i,t?.timestamp),c={contentTopic:this.topic,message:a.toBytes(),timestampNs:ue(a.sent)};return new yt(c,async()=>{await this.client.publishEnvelopes(r.map(p=>({contentTopic:p,message:a.toBytes(),timestamp:a.sent})));})}streamMessages(e){return F.create(this.client,[this.topic],async t=>this.decodeMessage(t),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");let r=await J.fromBytes(e),{senderAddress:i,recipientAddress:o}=r;if(!i||!o||!t||se(i,o)!==this.topic)throw new Error("Headers do not match intended recipient");return r}streamEphemeral(e){return F.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let r,i=await this.client.getUserContact(this.peerAddress);if(!i)throw new Error(`recipient ${this.peerAddress} is not registered`);i instanceof P||(i=i.toLegacyBundle());let o=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.has(this.peerAddress)?r=[this.topic]:(r=[de(this.peerAddress),de(this.client.address),o],this.client.contacts.add(this.peerAddress));let a=t?.contentType||Ee,c=await this.client.encodeContent(e,t),p=await this.createMessage(c,i,t?.timestamp);return await this.client.publishEnvelopes(r.map(l=>({contentTopic:l,message:p.toBytes(),timestamp:p.sent}))),q.fromV1Message(p,e,a,c,r[0],this)}async decryptBatch(e,t,r=!1){let i=(await this.client.keystore.decryptV1(kr(e,this.client.publicKeyBundle))).responses,o=[];for(let a=0;a<i.length;a++){let c=i[a],p=e[a];try{let{decrypted:l}=Ie(c);o.push(await this.buildDecodedMessage(p,l,t));}catch(l){if(r)throw l;console.warn("Error decoding content",l);}}return o}async buildDecodedMessage(e,t,r){let{content:i,contentType:o,error:a,contentFallback:c}=await this.client.decodeContent(t);return q.fromV1Message(e,i,o,t,r,this,a,c)}async createMessage(e,t,r){return r=r||new Date,J.encode(this.client.keystore,e,this.client.publicKeyBundle,t,r)}},ae=class{conversationVersion="v2";client;topic;peerAddress;createdAt;context;constructor(e,t,r,i,o){this.topic=t,this.createdAt=i,this.context=o,this.client=e,this.peerAddress=r;}get clientAddress(){return this.client.address}async messages(e){let t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return F.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return F.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let r=await this.client.encodeContent(e,t),i=await this.createMessage(r,t?.timestamp),o;t?.ephemeral?o=this.ephemeralTopic:o=this.topic,await this.client.publishEnvelopes([{contentTopic:o,message:i.toBytes(),timestamp:i.sent}]);let a=t?.contentType||Ee;return q.fromV2Message(i,e,a,this.topic,r,this,this.client.address)}async createMessage(e,t){let r={topic:this.topic,createdNs:D(t||new Date)},i=message.MessageHeaderV2.encode(r).finish(),o=await U(Gr(i,e)),a={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:o,prekeyIndex:0,identityKey:void 0})},c=content.SignedContent.encode(a).finish(),p=await this.encryptMessage(c,i),l={v1:void 0,v2:{headerBytes:i,ciphertext:p}},g=message.Message.encode(l).finish();return Se.create(l,r,g)}async decryptBatch(e,t=!1){let r=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,i=[];for(let o=0;o<r.length;o++){let a=r[o],c=e[o];try{let{decrypted:p}=Ie(a);i.push(await this.buildDecodedMessage(c,p));}catch(p){if(t)throw p;console.warn("Error decoding content",p);}}return i}buildDecryptRequest(e){return {requests:e.map(t=>({payload:t.ciphertext,headerBytes:t.headerBytes,contentTopic:this.topic}))}}async encryptMessage(e,t){let{responses:r}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(r.length!==1)throw new Error("Invalid response length");let{encrypted:i}=Ie(r[0]);return i}async buildDecodedMessage(e,t){let r=content.SignedContent.decode(t);if(!r.sender?.identityKey||!r.sender?.preKey||!r.signature)throw new Error("incomplete signed content");await Es(r);let i=await U(Gr(e.headerBytes,r.payload));if(!new E(r.sender?.preKey).verify(new S(r.signature),i))throw new Error("invalid signature");let o=await new A(r.sender).walletSignatureAddress(),{content:a,contentType:c,error:p,contentFallback:l}=await this.client.decodeContent(r.payload);return q.fromV2Message(e,a,c,this.topic,r.payload,this,o,p,l)}async prepareMessage(e,t){let r=await this.client.encodeContent(e,t),i=await this.createMessage(r,t?.timestamp),a={contentTopic:t?.ephemeral?this.ephemeralTopic:this.topic,message:i.toBytes(),timestampNs:ue(i.sent)};return new yt(a,async()=>{await this.client.publishEnvelopes([{contentTopic:this.topic,message:i.toBytes(),timestamp:i.sent}]);})}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");let t=message.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");let r=message.MessageHeaderV2.decode(t.v2.headerBytes);if(r.topic!==this.topic)throw new Error("topic mismatch");return Se.create(t,r,e.message)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");let t=await this.processEnvelope(e),r=await this.decryptBatch([t],!0);if(!r.length)throw new Error("No results");return r[0]}};async function Es(n){let e=n.sender?.preKey;if(!e||!e.signature||!e.keyBytes)throw new Error("missing pre-key or pre-key signature");let t=n.sender?.identityKey;if(!t)throw new Error("missing identity key in bundle");if(!await new E(t).verifyKey(new E(e)))throw new Error("pre key not signed by identity key")}var Yn=n=>{if(n.v1?.ciphertext)return [n.v1.headerBytes,new I(n.v1.ciphertext)];if(n.v2?.ciphertext)return [n.v2.headerBytes,new I(n.v2.ciphertext)];throw new Error("unknown message version")},Mr=class{headerBytes;ciphertext;contentType;error;id;bytes;constructor(e,t,r){[this.headerBytes,this.ciphertext]=Yn(r),this.id=e,this.bytes=t;}toBytes(){return this.bytes}},J=class extends Mr{header;senderAddress;conversation=void 0;constructor(e,t,r,i,o){super(e,t,r),this.senderAddress=o,this.header=i;}static async create(e,t,r){if(!t.sender)throw new Error("missing message sender");let i=new P(t.sender).walletSignatureAddress(),o=X(await U(r));return new J(o,r,e,t,i)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new V(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){let r=(await e.decryptV1(kr([this],t))).responses;if(!r.length)throw new Error("No response from Keystore");let{decrypted:i}=Ie(r[0]);return i}static fromBytes(e){let t=message.Message.decode(e),[r]=Yn(t),i=message.MessageHeaderV1.decode(r);if(!i)throw new Error("missing message header");if(!i.sender)throw new Error("missing message sender");if(!i.sender.identityKey)throw new Error("missing message sender identity key");if(!i.sender.preKey)throw new Error("missing message sender pre-key");if(!i.recipient)throw new Error("missing message recipient");if(!i.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!i.recipient.preKey)throw new Error("missing message recipient pre-key");return J.create(t,i,e)}static async encode(e,t,r,i,o){let a={sender:r,recipient:i,timestamp:kn.fromNumber(o.getTime())},c=message.MessageHeaderV1.encode(a).finish(),p=await e.encryptV1({requests:[{recipient:i,headerBytes:c,payload:t}]});if(!p.responses.length)throw new Error("No response from Keystore");let{encrypted:l}=Ie(p.responses[0]),g={v1:{headerBytes:c,ciphertext:l},v2:void 0},b=message.Message.encode(g).finish();return J.create(g,a,b)}},Se=class extends Mr{senderAddress;header;constructor(e,t,r,i){super(e,t,r),this.header=i;}static async create(e,t,r){let i=X(await U(r));return new Se(i,r,e,t)}get sent(){return _(this.header.createdNs)}},q=class{id;messageVersion;senderAddress;recipientAddress;sent;contentTopic;conversation;contentType;content;error;contentBytes;contentFallback;constructor({id:e,messageVersion:t,senderAddress:r,recipientAddress:i,conversation:o,contentBytes:a,contentType:c,contentTopic:p,content:l,sent:g,error:b,contentFallback:C}){this.id=e,this.messageVersion=t,this.senderAddress=r,this.recipientAddress=i,this.conversation=o,this.contentType=c,this.sent=g,this.error=b,this.content=l,this.contentTopic=p,this.contentBytes=a,this.contentFallback=C;}toBytes(){return message.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:D(this.conversation.createdAt),peerAddress:this.conversation.peerAddress},sentNs:D(this.sent)}).finish()}static async fromBytes(e,t){let r=message.DecodedMessage.decode(e),i=r.messageVersion;if(i!=="v1"&&i!=="v2")throw new Error("Invalid message version");if(!r.conversation)throw new Error("No conversation reference found");let{content:o,contentType:a,error:c,contentFallback:p}=await t.decodeContent(r.contentBytes);return new q({...r,content:o,contentType:a,error:c,messageVersion:i,sent:_(r.sentNs),conversation:xs(r.conversation,t,i),contentFallback:p})}static fromV1Message(e,t,r,i,o,a,c,p){let{id:l,senderAddress:g,recipientAddress:b,sent:C}=e;if(!g)throw new Error("Sender address is required");return new q({id:l,messageVersion:"v1",senderAddress:g,recipientAddress:b,sent:C,content:t,contentBytes:i,contentType:r,contentTopic:o,conversation:a,error:c,contentFallback:p})}static fromV2Message(e,t,r,i,o,a,c,p,l){let{id:g,sent:b}=e;return new q({id:g,messageVersion:"v2",senderAddress:c,sent:b,content:t,contentBytes:o,contentType:r,contentTopic:i,conversation:a,error:p,contentFallback:l})}};function xs(n,e,t){if(t==="v1")return new Q(e,n.peerAddress,_(n.createdNs));if(t==="v2")return new ae(e,n.topic,n.peerAddress,_(n.createdNs),n.context);throw new Error(`Unknown conversation version ${t}`)}function ks(n,e){return e.decodeContent(n)}var Bs=60*60-10,Ue=class{authenticator;token;maxAgeMs;constructor(e,t=Bs){this.authenticator=e,this.maxAgeMs=t*1e3;}async getToken(){return (!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken();}};var Zn={name:"@xmtp/xmtp-js",version:"11.1.0",description:"XMTP client SDK for interacting with XMTP networks.",type:"module",main:"dist/index.cjs",module:"dist/index.js",types:"dist/index.d.ts",browser:"dist/web/index.js",exports:{".":{types:"./dist/index.d.ts",browser:"./dist/web/index.js",import:"./dist/index.js",require:"./dist/index.cjs"}},scripts:{prebench:"npm run build:bench",bench:"node dist/bench/index.cjs",build:"npm run clean:dist && npm run build:node && npm run build:web","build:bench":"tsup --out-dir dist/bench --entry.0 bench/index.ts --format cjs","build:node":"tsup","build:web":"tsup --platform browser --target esnext","build:docs":"rimraf docs && mkdir -p tmp && cp README.md tmp/ && sed -i.bak '/badge.svg/d' tmp/README.md && typedoc --excludePrivate --readme tmp/README.md src/index.ts",clean:"npm run clean:dist && npm run clean:proto","clean:dist":"rimraf dist","clean:proto":"rimraf -g src/proto/*.ts",package:"npm pack",prepublishOnly:"npm run build",updateSnapVersion:`npm view @xmtp/snap --json | jq '{"version": .version, "package": .name}' > ./src/snapInfo.json`,"test:setup":"./dev/up","test:teardown":"./dev/down",test:"npm run test:node","test:node":"jest --no-cache --env='node' --testTimeout=30000","test:jsdom":"jest --no-cache --env='./jest.jsdom.env.cjs' --testTimeout=30000","test:cov":"jest --coverage --no-cache --runInBand",lint:"prettier --check . && eslint .",autolint:"prettier --write . && eslint --fix .","semantic-release":"semantic-release",typecheck:"tsc"},publishConfig:{access:"public",provenance:!0},files:["dist/index.cjs","dist/index.cjs.map","dist/index.d.ts","dist/index.js","dist/index.js.map","dist/web/index.js","dist/web/index.js.map"],keywords:["xmtp","messaging","web3","sdk","js","javascript","node","nodejs"],author:"XMTP Labs <eng@xmtp.com>",license:"MIT",homepage:"https://github.com/xmtp/xmtp-js",repository:{type:"git",url:"https:git@github.com:xmtp/xmtp-js.git"},bugs:{url:"https://github.com/xmtp/xmtp-js/issues"},release:{branches:["main",{name:"beta",prerelease:!0}]},dependencies:{"@noble/secp256k1":"^1.5.2","@xmtp/proto":"^3.28.0-beta.1","async-mutex":"^0.4.0",elliptic:"^6.5.4",ethers:"^5.5.3",long:"^5.2.0"},devDependencies:{"@commitlint/cli":"^17.7.1","@commitlint/config-conventional":"^16.0.0","@metamask/providers":"^11.1.1","@types/benchmark":"^2.1.2","@types/bl":"^5.0.2","@types/callback-to-async-iterator":"^1.1.4","@types/elliptic":"^6.4.14","@types/jest":"^28.1.3","@types/node":"^18.14.0","@typescript-eslint/eslint-plugin":"^6.7.2","@typescript-eslint/parser":"^6.7.2",benny:"^3.7.1","dd-trace":"^2.12.2",esbuild:"^0.17.16","esbuild-plugin-external-global":"^1.0.1",eslint:"^8.50.0","eslint-config-prettier":"^9.0.0","eslint-config-standard":"^17.1.0","eslint-plugin-import":"^2.28.1","eslint-plugin-jsdoc":"^46.8.2","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^5.0.0","eslint-plugin-promise":"^6.1.1",husky:"^7.0.4",jest:"^29.6.0","jest-environment-jsdom":"^28.1.3",prettier:"^3.0.3",rimraf:"^5.0.0","semantic-release":"^21.0.3","ts-jest":"^29.1.1","ts-node":"^10.9.1",tsup:"^6.7.0",typedoc:"^0.25.1",typescript:"^5.2.2",viem:"^1.12.1"},engines:{node:">=18"}};var ei=`
XX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV 
 XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV 
  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  
 XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   
XX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    

Connected to the XMTP 'dev' network. Use 'production' for production messages.
https://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments
`;var {MessageApi:Rr,SortDirection:he}=messageApi,Qr=100,Ds=16,Is="X-Client-Version",Us="X-App-Version",mt={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var $e=class extends Error{code;constructor(e,t){super(e),this.code=t;}static fromObject(e){return new $e(e.message,e.code)}},Vs=n=>n?!!(n.name==="AbortError"||n.message.includes("aborted")):!1,Ns=n=>!!(n&&"code"in n&&n.code===Ds),ti=n=>!Ns(n),Yr=n=>(!n.message||!n.message.length||typeof n.message=="string"&&(n.message=Kr(n.message)),n),Ve=class{pathPrefix;maxRetries;authCache;appVersion;version;constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/"+Zn.version,e===mt.dev&&console.info(ei);}async _query(e){try{return await Xe(Rr.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,Qr)}catch(t){throw $e.fromObject(t)}}_batchQuery(e){return Xe(Rr.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,Qr)}async _publish(e,t=0){let r=await this.getToken(),i=this.headers();i.set("Authorization",`Bearer ${r}`);try{return await Xe(Rr.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:i}],this.maxRetries,Qr,ti)}catch(o){if(ti(o)||t>=1)throw $e.fromObject(o);return await this.authCache?.refresh(),this._publish(e,t+1)}}_subscribe(e,t,r){let i=new AbortController;return (async()=>{for(;;){let a=new Date().getTime();try{if(await Rr.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:i.signal,mode:"cors",headers:this.headers()}),i.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),new Date().getTime()-a<1e3&&await Cr(1e3),r?.();}catch(c){if(Vs(c)||i.signal.aborted)return;console.info("Stream connection closed. Resubscribing",c.toString()),new Date().getTime()-a<1e3&&await Cr(1e3),r?.();}}})(),{unsubscribe:async()=>{i?.abort();}}}async query(e,{direction:t=he.SORT_DIRECTION_ASCENDING,limit:r}){let i=[];for await(let o of this.queryIteratePages(e,{direction:t,pageSize:r&&r<100?r:100}))for(let a of o)if(i.push(a),r&&i.length===r)return i;return i}async*queryIterator(e,t){for await(let r of this.queryIteratePages(e,t))for(let i of r)yield i;}async*queryIteratePages({contentTopic:e,startTime:t,endTime:r},{direction:i,pageSize:o=10}){if(!e||!e.length)throw new Error("Must specify content topics");let a=ue(t),c=ue(r),p;for(;;){let l={limit:o,direction:i,cursor:p},g=await this._query({contentTopics:[e],startTimeNs:a,endTimeNs:c,pagingInfo:l});if(g.envelopes?.length)yield g.envelopes.map(Yr);else return;if(g.pagingInfo?.cursor)p=g.pagingInfo?.cursor;else return}}async batchQuery(e){let r=[];for(let a=0;a<e.length;a+=50){let c=e.slice(a,a+50),p=[];for(let g of c)p.push({contentTopics:[g.contentTopic],startTimeNs:ue(g.startTime),endTimeNs:ue(g.endTime),pagingInfo:{limit:g.pageSize||10,direction:g.direction||he.SORT_DIRECTION_ASCENDING}});let l={requests:p};r.push(l);}let i=await Promise.all(r.map(async a=>this._batchQuery(a))),o=[];for(let a of i){if(!a.responses)throw new Error("BatchQueryResponse missing responses");for(let c of a.responses)c.envelopes?o.push(c.envelopes.map(Yr)):o.push([]);}return o}async publish(e){let t=[];for(let{contentTopic:r,message:i,timestamp:o}of e){if(!r.length)throw new Error("Content topic cannot be empty string");if(!i.length)throw new Error("0 length messages not allowed");let a=o||new Date;t.push({contentTopic:r,timestampNs:ue(a),message:Uint8Array.from(i)});}return this._publish({envelopes:t})}subscribe(e,t,r){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,i=>t(Yr(i)),r)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new Ue(e,t);}headers(){let e=new Headers;return e.set(Is,this.version),this.appVersion&&e.set(Us,this.appVersion),e}};var Qe=class{jobType;mutex;keystore;constructor(e,t){this.jobType=e,this.mutex=new Mutex,this.keystore=t;}get protoJobType(){return qs(this.jobType)}async run(e){return this.mutex.runExclusive(async()=>{let t=await this.getLastRunTime(),r=new Date,i=await e(t);return await this.setLastRunTime(r),i})}async getLastRunTime(){let{lastRunNs:e}=await this.keystore.getRefreshJob(keystore.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(kn.fromNumber(0)))return _(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:D(e)});}};function qs(n){let e={v1:keystore.JobType.JOB_TYPE_REFRESH_V1,v2:keystore.JobType.JOB_TYPE_REFRESH_V2}[n];if(!e)throw new Error(`unknown job type: ${n}`);return e}var ri=1e4,ni=n=>!!(n.recipientAddress&&n.senderAddress),Ne=class{client;v1JobRunner;v2JobRunner;constructor(e){this.client=e,this.v1JobRunner=new Qe("v1",e.keystore),this.v2JobRunner=new Qe("v2",e.keystore);}async list(){let[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),r=e.concat(t);return r.sort((i,o)=>i.createdAt.getTime()-o.createdAt.getTime()),r}async listFromCache(){let[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),r=e.concat(t);return r.sort((i,o)=>i.createdAt.getTime()-o.createdAt.getTime()),r}async listV1Conversations(){return this.v1JobRunner.run(async e=>{let t=await this.getIntroductionPeers({startTime:e?new Date(+e-ri):void 0,direction:he.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map(([r,i])=>({peerAddress:r,createdNs:D(i),topic:se(r,this.client.address),context:void 0}))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))})}async listV2Conversations(){return this.v2JobRunner.run(async e=>{let t=await this.getV2ConversationsFromKeystore(),r=await this.updateV2Conversations(e),i=new Set(t.map(o=>o.topic));for(let o of r)i.has(o.topic)||(t.push(o),i.add(o.topic));return t.sort((o,a)=>o.createdAt.getTime()-a.createdAt.getTime()),t})}async getV2ConversationsFromKeystore(){return (await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return (await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){let t=await this.client.listInvitations({startTime:e?new Date(+e-ri):void 0,direction:he.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){let{responses:r}=await this.client.keystore.saveInvites({requests:e.map(o=>({payload:o.message,timestampNs:kn.fromString(o.timestampNs),contentTopic:o.contentTopic}))}),i=[];for(let o of r)try{i.push(this.saveInviteResponseToConversation(o));}catch(a){if(console.warn("Error saving invite response to conversation: ",a),t)throw a}return i}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new ae(this.client,e.topic,e.peerAddress,_(e.createdNs),e.context)}conversationReferenceToV1(e){return new Q(this.client,e.peerAddress,_(e.createdNs))}async stream(e){let t=new Set,r=de(this.client.address),i=Ke(this.client.address),o=p=>t.has(p)?!1:(t.add(p),!0),a=async p=>{if(p.contentTopic===r){if(!p.message)throw new Error("empty envelope");let l=await J.fromBytes(p.message),g=this.getPeerAddress(l);return o(g)?(await l.decrypt(this.client.keystore,this.client.publicKeyBundle),new Q(this.client,g,l.sent)):void 0}if(p.contentTopic===i){let l=await this.decodeInvites([p],!0);if(l.length)return l[0]}throw new Error("unrecognized invite topic")},c=[r,i];return F.create(this.client,c,a.bind(this),void 0,e)}async streamAllMessages(e){let t=de(this.client.address),r=Ke(this.client.address),i=new Set([t,r]),o=new Map;for(let b of await this.list())i.add(b.topic),o.set(b.topic,b);let a=async b=>{let C=b.contentTopic;if(!C||!b.message)return null;if(C===t){let R=await J.fromBytes(b.message);if(!ni(R))return null;let Pe=this.getPeerAddress(R);return new Q(this.client,Pe,R.sent).decodeMessage(b)}if(C===r)return (await this.decodeInvites([b],!0))[0];let ie=o.get(C);if(ie instanceof Q||ie instanceof ae)return ie.decodeMessage(b);throw console.log("Unknown topic"),new Error("Unknown topic")},c=(b,C)=>i.has(b)?!1:(o.set(b,C),i.add(b),!0),p=b=>{if(b instanceof q&&b.contentTopic===t){let C=new Q(this.client,b.recipientAddress===this.client.address?b.senderAddress:b.recipientAddress,b.sent);return c(C.topic,C)?Array.from(i.values()):void 0}if(b instanceof ae)return c(b.topic,b)?Array.from(i.values()):void 0},l=await F.create(this.client,Array.from(i.values()),a,p,e),g=async function*(){for await(let C of l)if(C instanceof q&&(yield C),C instanceof ae)for(let ie of await C.messages())yield ie;}();return g.return=async()=>(await l?.return(),{value:void 0,done:!0}),g}async getIntroductionPeers(e){let t=de(this.client.address),r=await this.client.listEnvelopes(t,o=>{if(!o.message)throw new Error("empty envelope");return J.fromBytes(o.message)},e),i=new Map;for(let o of r){if(!ni(o))continue;let a=this.getPeerAddress(o);if(a){let c=i.get(a);if(!c||c>o.sent)try{await o.decrypt(this.client.keystore,this.client.publicKeyBundle),i.set(a,o.sent);}catch{continue}}}return i}async newConversation(e,t){let r=await this.client.getUserContact(e);if(!r)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e===this.client.address)throw new Error("self messaging not supported");if(r instanceof P&&!t?.conversationId)return new Q(this.client,e,new Date);if(!t?.conversationId){let p=(await this.listV1Conversations()).find(l=>l.peerAddress===e);if(p){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(r instanceof P)&&!r.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return p}}r instanceof P&&(r=A.fromLegacyBundle(r));let i=c=>c.peerAddress===e&&Fs(t,c.context??void 0),a=(await this.getV2ConversationsFromKeystore()).find(i);return a||this.v2JobRunner.run(async c=>{let l=(await this.updateV2Conversations(c)).find(i);return l||this.createV2Convo(r,t)})}async createV2Convo(e,t){let r=new Date,{payload:i,conversation:o}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:D(r)});if(!i||!o)throw new Error("Required field not returned from Keystore");let a=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ke(a),message:i,timestamp:r},{contentTopic:Ke(this.client.address),message:i,timestamp:r}]),this.conversationReferenceToV2(o)}getPeerAddress(e){return e.recipientAddress===this.client.address?e.senderAddress:e.recipientAddress}};function Fs(n,e){return n?.conversationId===e?.conversationId}async function si(n,e){if(n.compression===void 0)return;let t={bytes:new Uint8Array(n.content.length)};await ci(n.content).pipeThrough(new DecompressionStream(ai(n.compression))).pipeTo(pi(t,e)),n.content=t.bytes;}async function oi(n){if(n.compression===void 0)return;let e={bytes:new Uint8Array(n.content.length/10)};await ci(n.content).pipeThrough(new CompressionStream(ai(n.compression))).pipeTo(pi(e,n.content.length+1e3)),n.content=e.bytes;}function ai(n){if(n===content.Compression.COMPRESSION_GZIP)return "gzip";if(n===content.Compression.COMPRESSION_DEFLATE)return "deflate";throw new Error("unrecognized compression algorithm")}function ci(n,e=1024){let t=0;return new ReadableStream({pull(r){if(t>=n.length)return r.close();let i=t+e;i=i<=n.length?i:n.length,r.enqueue(n.subarray(t,i)),t=i;}})}function pi(n,e){let t=0;return new WritableStream({write(r){let i=t+r.length;if(i>e)throw new Error("maximum output size exceeded");for(;n.bytes.length<i;)n.bytes=Hs(n.bytes,e);n.bytes.set(r,t),t=i;},close(){t<n.bytes.length&&(n.bytes=n.bytes.subarray(0,t));}})}function Hs(n,e){let t=n.length*2;t>e&&(t=e);let r=new Uint8Array(t);return r.set(n),r}function Dr(n){let e;try{e=contact.ContactBundle.decode(n);}catch{let r=publicKey.PublicKeyBundle.decode(n);e={v1:{keyBundle:new P(r)},v2:void 0};}if(e.v1?.keyBundle)return new P(e.v1.keyBundle);if(e.v2?.keyBundle)return new A(e.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function di(n){return n instanceof P?contact.ContactBundle.encode({v1:{keyBundle:n},v2:void 0}).finish():contact.ContactBundle.encode({v1:void 0,v2:{keyBundle:n}}).finish()}var mi=xn(ui(),1);var ce=class{walletAddr;createdNs;constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t;}static create(e,t){return t=t||new Date,new ce({walletAddr:e,createdNs:D(t)})}static fromBytes(e){let t=authn.AuthData.decode(e);return new ce(t)}toBytes(){return authn.AuthData.encode(this).finish()}};var pe=class{identityKey;authDataBytes;authDataSignature;_authData;constructor({identityKey:e,authDataBytes:t,authDataSignature:r}){if(!e)throw new Error("Missing identity key in token");if(!r)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=r;}get authData(){return this._authData||(this._authData=ce.fromBytes(this.authDataBytes)),this._authData}get ageMs(){let e=new Date().valueOf(),r=this.authData.createdNs.div(1e6).toNumber();return e-r}toBytes(){return authn.Token.encode(this).finish()}static fromBytes(e){return new pe(authn.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}};var ge=class{identityKey;constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e;}async createToken(e){let r=ce.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),i=(0, mi.keccak256)(r),o=await this.identityKey.sign(z(i));return new pe(authn.Token.fromPartial({identityKey:publicKey.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:r,authDataSignature:signature.Signature.fromPartial(o)}))}};var Xs=n=>n instanceof pe?n:new pe(n),Ye=class{keystore;constructor(e){this.keystore=e;}async createToken(e){let t=await this.keystore.createAuthToken({timestampNs:e?D(e):void 0});return Xs(t)}};var fi=0,Ze=class{configuration;static createConfiguration(){return {type:fi,version:0}}constructor(e){this.configuration=e;}get backupType(){return fi}};var hi=1,et=class{configuration;static createConfiguration(e){return {type:hi,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e;}get backupType(){return hi}};async function gi(n,e){let t=await zs(n,e);switch(t.type){case 0:return new Ze(t);case 1:return new et(t)}}async function zs(n,e){let t;switch((await e()).type){case 0:t=Ze.createConfiguration();break;case 1:t=et.createConfiguration(n);break}return t}var L=class extends Error{};var ke=class{topic;context;aes256GcmHkdfSha256;constructor({topic:e,context:t,aes256GcmHkdfSha256:r}){if(!e||!e.length)throw new Error("Missing topic");if(!r||!r.keyMaterial||!r.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=r;}static createRandom(e){let t=pt(Buffer.from(M.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace("/","-")),r=M.getRandomValues(new Uint8Array(32));return new ke({topic:t,aes256GcmHkdfSha256:{keyMaterial:r},context:e})}toBytes(){return invitation.InvitationV1.encode(this).finish()}static fromBytes(e){return new ke(invitation.InvitationV1.decode(e))}},tt=class{sender;recipient;createdNs;constructor({sender:e,recipient:t,createdNs:r}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new A(e),this.recipient=new A(t),this.createdNs=r;}toBytes(){return invitation.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new tt(invitation.SealedInvitationHeaderV1.decode(e))}},ft=class{headerBytes;ciphertext;_header;_invitation;constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new I(t);}get header(){return this._header?this._header:(this._header=tt.fromBytes(this.headerBytes),this._header)}async getInvitation(e){if(this._invitation)return this._invitation;let t=this.header,r;e.identityKey.matches(this.header.sender.identityKey)?r=await e.sharedSecret(t.recipient,t.sender.preKey,!1):r=await e.sharedSecret(t.sender,t.recipient.preKey,!0);let i=await j(this.ciphertext,r,this.headerBytes);return this._invitation=ke.fromBytes(i),this._invitation}toBytes(){return invitation.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new ft(invitation.SealedInvitationV1.decode(e))}},le=class{v1;constructor({v1:e}){if(e)this.v1=new ft(e);else throw new Error("Missing v1 or v2 invitation")}toBytes(){return invitation.SealedInvitation.encode(this).finish()}static fromBytes(e){return new le(invitation.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");let t=le.fromBytes(e.message),r=kn.fromString(e.timestampNs),i=t.v1?.header.createdNs;if(!i||!i.equals(r))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:r,invitation:i}){let o=new tt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:D(r)}).toBytes(),a=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),c=i.toBytes(),p=await ee(c,a,o);return new le({v1:{headerBytes:o,ciphertext:p}})}};var vi=async(n,e,t,r,i)=>{let o=await n.sharedSecret(e,n.getCurrentPreKey().publicKey,!i);return j(t,o,r)},wi=async(n,e,t,r)=>{let i=await n.sharedSecret(e,n.getCurrentPreKey().publicKey,!1);return ee(t,i,r)},bi=(n,e,t)=>j(n,e,t),Pi=(n,e,t)=>ee(n,e,t);var nn=(n,e)=>n instanceof K?n:new K(e,n.message),Qs=n=>({result:n}),rt=(n,e,t)=>Promise.all(n.map(async r=>{try{return Qs(await e(r))}catch(i){return {error:nn(i,t)}}})),sn=n=>n instanceof P?n:new P(n),Ci=n=>n instanceof A?n:new A(n),Oe=(n,e,t)=>{for(let r of e)if(!n[r])throw new K(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(r)}`);for(let r of t){let i=n[r];if(!i||!i?.length)throw new K(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(r)}`)}return !0},on=n=>{if(!n?.aes256GcmHkdfSha256?.keyMaterial)throw new K(keystore.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return n.aes256GcmHkdfSha256.keyMaterial},Ur=({invitation:n,createdNs:e,peerAddress:t})=>({context:n.context,topic:n.topic,peerAddress:t,createdNs:e}),Ki=n=>!!n.invitation,Ai=n=>{let e=new Map;for(let[t,r]of Object.entries(n.topics))e.set(t,r);return e},Ti=(n,e)=>`xmtp/${n}/${e}/`;var Zs="invitations/v1",eo="conversation-v1/v1",Be=class{persistence;persistenceKey;mutex;topicMap;revision;constructor(e,t,r=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new Mutex,this.topicMap=r;}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){let t=Zs,r=new Be(e,t);return await r.refresh(),r}validate(e){return !!e.topic&&e.topic.length>0&&Ki(e)}async refresh(){let e=await this.getRevision();if(e>this.revision)for(let[t,r]of await this.loadFromPersistence())this.topicMap.set(t,r);this.revision=e;}async getRevision(){let e=await this.persistence.getItem(this.revisionKey);return e?Rn(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,Mn(e));}async loadFromPersistence(){let e=await this.persistence.getItem(this.persistenceKey);return e?Ai(keystore.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision);}async add(e){await this.mutex.runExclusive(async()=>{await this.refresh();let t=!1;for(let r of e){if(!this.validate(r)){console.warn("Invalid topic data",r.topic);continue}let{topic:i,...o}=r;this.topicMap.has(i)||(this.topicMap.set(i,o),t=!0);}t&&await this.store();});}get topics(){return [...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return keystore.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}},_e=class extends Be{static async create(e){let t=eo,r=new _e(e,t);return await r.refresh(),r}validate(e){return !!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}};var ro=to.ec,cn=new ro("secp256k1"),ht=M.subtle,no=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),io=Buffer.alloc(32,0);function me(n,e){if(!n)throw new Error(e||"Assertion failed")}function so(n){return Buffer.isBuffer(n)&&n.length===32}function pn(n){return so(n)?n.compare(io)>0&&n.compare(no)<0:!1}function oo(n,e){if(n.length!==e.length)return !1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}function an(n){let e=new Uint8Array(n);return M.getRandomValues(e),Buffer.from(e)}async function Si(n){let e=await ht.digest("SHA-512",n);return Buffer.from(e)}function xi(n){return function(e,t,r){return new Promise(function(i){let o={name:"AES-CBC"};return ht.importKey("raw",t,o,!1,[n]).then(function(c){let p={name:"AES-CBC",iv:e};return ht[n](p,c,r)}).then(function(c){i(Buffer.from(new Uint8Array(c)));})})}}var ao=xi("encrypt"),co=xi("decrypt");async function Vr(n,e){let t=await ht.importKey("raw",n,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await ht.sign({name:"HMAC",hash:"SHA-256"},t,e))}async function po(n,e,t){let r=await Vr(n,e);return oo(r,t)}function dn(n){return me(n.length===32,"Bad private key"),me(pn(n),"Bad private key"),Buffer.from(cn.keyFromPrivate(n).getPublic("array"))}function ki(n,e){return new Promise(function(t){me(Buffer.isBuffer(n),"Bad private key"),me(Buffer.isBuffer(e),"Bad public key"),me(n.length===32,"Bad private key"),me(pn(n),"Bad private key"),me(e.length===65||e.length===33,"Bad public key"),e.length===65&&me(e[0]===4,"Bad public key"),e.length===33&&me(e[0]===2||e[0]===3,"Bad public key");let r=cn.keyFromPrivate(n),i=cn.keyFromPublic(e),o=r.derive(i.getPublic());t(Buffer.from(o.toArray()));})}async function Bi(n,e,t){t=t||{};let r=t?.iv||an(16),i=t?.ephemPrivateKey||an(32);for(;!pn(i);){if(t?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");i=an(32);}let o=dn(i),a=await Si(await ki(i,n)),c=a.slice(0,32),p=a.slice(32),l=await ao(r,c,e),g=Buffer.concat([r,o,l]),b=await Vr(p,g);return {iv:r,ephemeralPublicKey:o,ciphertext:l,mac:b}}async function Mi(n,e){let t=await ki(n,e.ephemeralPublicKey),r=await Si(t),i=r.slice(0,32),o=r.slice(32),a=Buffer.concat([e.iv,e.ephemeralPublicKey,e.ciphertext]);return me(await po(o,a,e.mac),"Bad mac"),co(e.iv,i,e.ciphertext)}var{ErrorCode:W}=keystore,uo=new TextEncoder().encode("__XMTP__INVITATION__SALT__XMTP__");async function yo(n,e){let t=await M.subtle.importKey("raw",n,"HKDF",!1,["deriveKey"]);return M.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:uo,info:e},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}var Z=class{v1Keys;v2Keys;v1Store;v2Store;authenticator;accountAddress;jobStatePersistence;constructor(e,t,r,i){this.v1Keys=e,this.v2Keys=G.fromLegacyBundle(e),this.v1Store=t,this.v2Store=r,this.authenticator=new ge(e.identityKey),this.jobStatePersistence=i;}static async create(e,t){return new Z(e,await _e.create(t),await Be.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload","peerKeys"],["headerBytes"]));let{payload:i,peerKeys:o,headerBytes:a,isSender:c}=r;return {decrypted:await vi(this.v1Keys,sn(o),i,a,c)}},keystore.ErrorCode.ERROR_CODE_UNSPECIFIED);return keystore.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload"],["headerBytes"]));let{payload:i,headerBytes:o,contentTopic:a}=r,c=this.v2Store.lookup(a);if(!c)throw new K(keystore.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return {decrypted:await bi(i,on(c.invitation),o)}},W.ERROR_CODE_UNSPECIFIED);return keystore.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload","recipient"],["headerBytes"]));let{recipient:i,payload:o,headerBytes:a}=r;return {encrypted:await wi(this.v1Keys,sn(i),o,a)}},W.ERROR_CODE_UNSPECIFIED);return keystore.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?_(e):void 0)}async encryptV2(e){let t=await rt(e.requests,async r=>{if(!Oe(r,["payload"],["headerBytes"]));let{payload:i,headerBytes:o,contentTopic:a}=r,c=this.v2Store.lookup(a);if(!c)throw new K(W.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");return {encrypted:await Pi(i,on(c.invitation),o)}},W.ERROR_CODE_INVALID_INPUT);return keystore.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){let t=[],r=await rt(e.requests,async({payload:i,timestampNs:o})=>{let a=le.fromBytes(i);if(a.v1){if(!a.v1.header.createdNs.equals(o))throw new Error("envelope and header timestamp mismatch");let p=a.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),l=await a.v1.getInvitation(this.v2Keys),g={invitation:l,createdNs:a.v1.header.createdNs,peerAddress:p?await a.v1.header.recipient.walletSignatureAddress():await a.v1.header.sender.walletSignatureAddress()};return t.push({...g,topic:l.topic}),{conversation:Ur(g)}}},W.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),keystore.SaveInvitesResponse.fromPartial({responses:r})}async createInvite(e){try{if(!Oe(e,["recipient"],[]));let t=_(e.createdNs),r=Ci(e.recipient),i=await this.getAccountAddress(),o=await r.walletSignatureAddress(),a=await this.v2Keys.sharedSecret(r,this.v2Keys.getCurrentPreKey().publicKey,i<o),c=[i,o].sort(),p=(e.context?.conversationId||"")+c.join(),l=new TextEncoder().encode(p),g=X(await Vr(Buffer.from(a),Buffer.from(l))),b=["0",...c].join("|"),C=new TextEncoder().encode(b),ie=await yo(a,C),R=new Uint8Array(await M.subtle.exportKey("raw",ie)),Pe=new ke({topic:pt(g),aes256GcmHkdfSha256:{keyMaterial:R},context:e.context}),it=await le.createV1({sender:this.v2Keys,recipient:r,created:t,invitation:Pe}),We={invitation:Pe,topic:Pe.topic,createdNs:e.createdNs,peerAddress:await r.walletSignatureAddress()};return await this.v2Store.add([We]),keystore.CreateInviteResponse.fromPartial({conversation:Ur(We),payload:it.toBytes()})}catch(t){throw nn(t,W.ERROR_CODE_INVALID_INPUT)}}async signDigest(e){if(!Oe(e,["digest"],[]));let{digest:t,identityKey:r,prekeyIndex:i}=e,o;if(r)o=this.v1Keys.identityKey;else if(typeof i<"u"&&Number.isInteger(i)){if(o=this.v1Keys.preKeys[i],!o)throw new K(W.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}else throw new K(W.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");return o.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map(t=>({topic:se(t.peerAddress,this.walletAddress),peerAddress:t.peerAddress,createdNs:t.createdNs,invitation:void 0}))),{}}async getV1Conversations(){return {conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){let e=this.v2Store.topics.map(t=>Ur(t));return e.sort((t,r)=>t.createdNs.div(1e6).sub(r.createdNs.div(1e6)).toNumber()),keystore.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===keystore.JobType.JOB_TYPE_UNSPECIFIED)throw new K(W.ERROR_CODE_INVALID_INPUT,"invalid job type");let t=await this.getLastRunTime(e);return keystore.GetRefreshJobResponse.fromPartial({lastRunNs:t||kn.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){let r=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(r,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return {peerAddress:e.peerAddress,createdNs:e.createdNs,topic:se(e.peerAddress,this.walletAddress),context:void 0}}buildJobStorageKey(e){return `refreshJob/${e.toString()}`}async getLastRunTime(e){let t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(!(!t||!t.length))return kn.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}};var qe=class{apiClient;constructor(e){this.apiClient=e;}async getItem(e){for await(let t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:messageApi.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(r){console.log(r);}return null}async setItem(e,t){let r=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:r}]);}setAuthenticator(e){this.apiClient.setAuthenticator(e);}buildTopic(e){return Fr(e)}};var ne=class{storage;constructor(e){this.storage=e;}static create(){if(typeof localStorage>"u")throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new ne(localStorage)}async getItem(e){let t=this.storage.getItem(e);return t===null?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"));}};var gt=class{store;constructor(){this.store=new Map;}get length(){return this.store.size}clear(){this.store=new Map;}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(e===void 0)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");let t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e);}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t));}validateString(e){if(typeof e!="string")throw new TypeError("Key must be a string")}};var ve=class extends ne{static create(){return new ne(new gt)}};var Le=class{prefix;persistence;constructor(e,t){this.prefix=e,this.persistence=t;}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}};var Fe=class{persistence;privateKey;privateKeyBytes;publicKey;constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=dn(this.privateKeyBytes);}async getItem(e){let t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){let r=await this.encrypt(t);await this.persistence.setItem(e,r);}async encrypt(e){let t=await Bi(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){let t=await this.deserializeEcies(e),r=await Mi(this.privateKeyBytes,t);return Uint8Array.from(r)}async serializeEcies(e){return (await ye.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){let t=ye.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");let r=t.ciphertext;return {ciphertext:Buffer.from(r.ciphertext),mac:Buffer.from(r.mac),iv:Buffer.from(r.iv),ephemeralPublicKey:Buffer.from(r.ephemeralPublicKey)}}};var nt=async(n,e)=>{if(!n.persistConversations)return ve.create();let t=await e.identityKey.publicKey.walletSignatureAddress(),r=Ti(n.env,t),i=n.basePersistence,o=!n.disablePersistenceEncryption;return new Le(r,o?new Fe(i,e.identityKey):i)};var Di="key_bundle",He=class{persistence;signer;preEnableIdentityCallback;constructor(e,t,r){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=r;}async getStorageAddress(e){let t=await this.signer.getAddress();return t=utils.getAddress(t),`${t}/${e}`}async loadPrivateKeyBundle(){let e=await this.persistence.getItem(await this.getStorageAddress(Di));if(!e)return null;let[t,r]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return r&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){let t=await this.getStorageAddress(Di),r=await this.toEncryptedBytes(e,this.signer);typeof this.persistence.setAuthenticator=="function"&&this.persistence.setAuthenticator(new ge(e.identityKey)),await this.persistence.setItem(t,r);}async toEncryptedBytes(e,t){let r=e.encode(),i=M.getRandomValues(new Uint8Array(32)),o=Ui(i),a=await t.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();let c=await t.signMessage(o),p=utils.verifyMessage(o,c);if(p!==a&&(c=await t.signMessage(o),console.log("invalid signature, retrying"),p=utils.verifyMessage(o,c),p!==a))throw new Error("invalid signature");let l=z(c),g=await ee(r,l);return privateKey.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:i,ciphertext:g}}).finish()}async fromEncryptedBytes(e,t){let[r,i]=mo(t);if(!r.walletPreKey)throw new Error("missing wallet pre-key");if(!r.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();let o=z(await e.signMessage(Ui(r.walletPreKey)));try{let a=new I(r.ciphertext),c=await j(a,o),[p,l]=Ii(c);return [p,i||l]}catch{if(o.length!==65)throw new Error("Expected 65 bytes before trying a different recovery byte");let c=o[o.length-1],p=o.slice(0,o.length-1);c<27?p=new Uint8Array([...p,c+27]):p=new Uint8Array([...p,c-27]);let l=new I(r.ciphertext),g=await j(l,p),[b,C]=Ii(g);return [b,i||C]}}};function mo(n){try{let e=privateKey.EncryptedPrivateKeyBundle.decode(n);if(e.v1)return [e.v1,!1]}catch{return [privateKey.EncryptedPrivateKeyBundleV1.decode(n),!0]}throw new Error("unrecognized encrypted private key bundle version")}function Ii(n){try{let e=De(n);if(e instanceof G)throw new Error("V2 bundles not supported yet");return [e,!1]}catch{let t=privateKey.PrivateKeyBundleV1.decode(n);return [new N(t),!0]}}function Ui(n){return `XMTP : Enable Identity
${X(n)}

For more info: https://xmtp.org/signatures/`}var we=class{async newKeystore(e,t,r){if(!r)throw new L("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();let i=await N.generate(r);return await new He(r,new qe(t),e.preEnableIdentityCallback).storePrivateKeyBundle(i),Z.create(i,await nt(e,i))}};var be=class{async newKeystore(e,t,r){if(!r)throw new L("No wallet provided");let o=await new He(r,new qe(t),e.preEnableIdentityCallback).loadPrivateKeyBundle();if(!o)throw new L("No keys found");return Z.create(o,await nt(e,o))}};var Ge=class{async newKeystore(e){let{privateKeyOverride:t}=e;if(!t)throw new L("No private key override provided");let r=De(t);if(r instanceof G)throw new Error("V2 private key bundle found. Only V1 supported");return Z.create(r,await nt(e,r))}};function vt(){return window.ethereum}var{GetKeystoreStatusResponse_KeystoreStatus:Vi,InitKeystoreRequest:ho,InitKeystoreResponse:go,GetKeystoreStatusRequest:vo,GetKeystoreStatusResponse:wo}=keystore;async function Or(n,e,t,r,i){let o=null;if(e.req){let c=e.req.encode(t).finish();o=Bn(c,0,c.length);}let a=await bo(n,o,r,i);if(Array.isArray(a))throw new Error("Unexpected array response");return e.res.decode(Kr(a))}async function bo(n,e,t,r){let i={meta:t};typeof e=="string"&&(i.req=e);let o=await vt().request({method:"wallet_invokeSnap",params:{snapId:r,request:{method:n,params:i}}});if(!o||typeof o!="object")throw new Error("No response value");return o.res}async function _r(){let n=vt();if(n?.isMetaMask)try{return await n.request({method:"wallet_getSnaps"}),!0}catch{}if(typeof n?.detected<"u"&&Array.isArray(n.detected))for(let e of n.detected)try{return await e.request({method:"wallet_getSnaps"}),n?.setProvider?.(e),!0}catch{}if(typeof n?.providers<"u"&&Array.isArray(n.providers))for(let e of n.providers)try{return await e.request({method:"wallet_getSnaps"}),window.ethereum=e,!0}catch{}return !1}async function Po(){return await vt()?.request({method:"wallet_getSnaps"})}async function Ni(n,e){try{let t=await Po();return Object.values(t).find(r=>r.id===n&&(!e||In(r.version,e)))}catch(t){console.warn("Failed to obtain installed snap",t);return}}async function Oi(n,e={}){await vt()?.request({method:"wallet_requestSnaps",params:{[n]:e}});}var Co={req:vo,res:wo};async function _i(n,e){let t=await Or("getKeystoreStatus",Co,{walletAddress:n.walletAddress},n,e);if([Vi.KEYSTORE_STATUS_UNSPECIFIED,Vi.UNRECOGNIZED].includes(t.status))throw new Error("No status specified in response");return t.status}var Ko={req:ho,res:go};async function qi(n,e,t){let r=n.identityKey.publicKey.walletSignatureAddress(),i=await Or("initKeystore",Ko,{v1:n},{walletAddress:r,env:e},t);if(i.error)throw new K(i.error.code,i.error.message)}var wt={decryptV1:{req:keystore.DecryptV1Request,res:keystore.DecryptResponse},encryptV1:{req:keystore.EncryptV1Request,res:keystore.EncryptResponse},encryptV2:{req:keystore.EncryptV2Request,res:keystore.EncryptResponse},decryptV2:{req:keystore.DecryptV2Request,res:keystore.DecryptResponse},saveInvites:{req:keystore.SaveInvitesRequest,res:keystore.SaveInvitesResponse},createInvite:{req:keystore.CreateInviteRequest,res:keystore.CreateInviteResponse},createAuthToken:{req:keystore.CreateAuthTokenRequest,res:authn.Token},signDigest:{req:keystore.SignDigestRequest,res:signature.Signature},getPublicKeyBundle:{req:null,res:publicKey.PublicKeyBundle},saveV1Conversations:{req:keystore.SaveV1ConversationsRequest,res:keystore.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:keystore.GetConversationsResponse},getV2Conversations:{req:null,res:keystore.GetConversationsResponse},getRefreshJob:{req:keystore.GetRefreshJobRequest,res:keystore.GetRefreshJobResponse},setRefreshJob:{req:keystore.SetRefeshJobRequest,res:keystore.SetRefreshJobResponse}};async function Li(n,e,t,r){return Or(n,wt[n],e,t,r)}function yn(n,e,t){let r={},i={walletAddress:n,env:e};for(let[o,a]of Object.entries(wt))r[o]=async c=>a.req?Li(o,c,i,t):Li(o,null,i,t);return {...r,async getAccountAddress(){return n}}}var {GetKeystoreStatusResponse_KeystoreStatus:xo}=keystore,ko="local:http://localhost:8080",Je=class{snapId;snapVersion;constructor(e=ko,t){this.snapId=e,this.snapVersion=t;}async newKeystore(e,t,r){if(!r)throw new L("No wallet provided");if(!await _r())throw new L("MetaMask with Snaps not detected");let i=await r.getAddress(),o=e.env,a=await Ni(this.snapId,this.snapVersion);if((!a||Un(this.snapVersion,a.version))&&await Oi(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await Do(i,o,this.snapId)){let c=await Mo(e,t,r);await qi(c,o,this.snapId);}return yn(i,o,this.snapId)}};async function Bo(n,e,t){let i=await new we().newKeystore(n,e,t);return new N(await i.getPrivateKeyBundle())}async function Mo(n,e,t){if(n.privateKeyOverride){let r=De(n.privateKeyOverride);if(!(r instanceof N))throw new Error("Unsupported private key bundle version");return r}if(!t)throw new Error("No privateKeyOverride or wallet");return Ro(n,e,t)}async function Ro(n,e,t){let r=new be;try{let i=await r.newKeystore(n,e,t);return new N(await i.getPrivateKeyBundle())}catch(i){if(i instanceof L)return Bo(n,e,t);throw i}}async function Do(n,e,t){return await _i({walletAddress:n,env:e},t)===xo.KEYSTORE_STATUS_INITIALIZED}var Hi="1.2.2",Gi="@xmtp/snap";var {Compression:Uo}=content,Wi=100*1024*1024;function Vo(n){let e={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new lt],maxContentSize:Wi,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:Dn()?ne.create():ve.create(),disablePersistenceEncryption:!1,keystoreProviders:ji(),apiClientFactory:No};return n?.codecs&&(n.codecs=e.codecs.concat(n.codecs)),n?.useSnaps&&(n.keystoreProviders=[new Je(`npm:${Gi}`,Hi),...e.keystoreProviders]),{...e,...n}}var Me=class{address;keystore;apiClient;contacts;publicKeyBundle;knownPublicKeyBundles;_backupClient;_conversations;_codecs;_maxContentSize;constructor(e,t,r,i){this.contacts=new Set,this.knownPublicKeyBundles=new Map,this.keystore=i,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new Ne(this),this._codecs=new Map,this._maxContentSize=Wi,this.apiClient=t,this._backupClient=r;}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return A.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){let r=Jr(e),i=Vo(t),o=i.apiClientFactory(i),a=await Oo(i,o,r),c=new P(await a.getPublicKeyBundle()),p=c.walletSignatureAddress();o.setAuthenticator(new Ye(a));let l=await Me.setupBackupClient(p,i.env),g=new Me(c,o,l,a);return await g.init(i),g}static async getKeys(e,t){let i=await(await Me.create(Jr(e),t)).keystore.getPrivateKeyBundle();return new N(i).encode()}static isSnapsReady(){return _r()}static async setupBackupClient(e,t){return gi(e,async()=>Promise.resolve({type:t==="local"?1:0}))}async init(e){e.codecs.forEach(t=>{this.registerCodec(t);}),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact);}async close(){}async ensureUserContactPublished(e=!1){let t=await ln(this.apiClient,this.address);t&&t instanceof A&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e));}async publishUserContact(e=!1){let t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:dt(this.address),message:di(t)}]);}async getUserContact(e){e=utils.getAddress(e);let t=this.knownPublicKeyBundles.get(e);if(t)return t;let r=await ln(this.apiClient,e);return r&&this.knownPublicKeyBundles.set(e,r),r}async getUserContacts(e){let t=e.map(a=>utils.getAddress(a)),r=new Map,i=[];for(let a of t){let c=this.knownPublicKeyBundles.get(a);c?r.set(a,c):(r.set(a,void 0),i.push(a));}let o=await Ji(this.apiClient,i);for(let a=0;a<o.length;a++){let c=i[a],p=o[a];r.set(c,p),p&&this.knownPublicKeyBundles.set(c,p);}return t.map(a=>r.get(a))}forgetContact(e){e=utils.getAddress(e),this.knownPublicKeyBundles.delete(e);}async canMessage(e){try{return Array.isArray(e)?(await this.getUserContacts(e)).map(i=>!!i):await this.getUserContact(e)!==void 0}catch{return !1}}static async canMessage(e,t){let r=t?.apiUrl||mt[t?.env||"dev"],i=new Ve(r,{appVersion:t?.appVersion});if(Array.isArray(e)){let c=e.map(l=>utils.getAddress(l));return (await Ji(i,c)).map(l=>!!l)}try{e=utils.getAddress(e);}catch{return !1}return await ln(i,e)!==void 0}validateEnvelope(e){let t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(let t of e)this.validateEnvelope(t);await this.apiClient.publish(e);}registerCodec(e){let t=e.contentType,r=`${t.authorityId}/${t.typeId}`;return this._codecs.set(r,e),this}codecFor(e){let t=`${e.authorityId}/${e.typeId}`,r=this._codecs.get(t);if(r&&!(e.versionMajor>r.contentType.versionMajor))return r}async encodeContent(e,t){let r=t?.contentType||Ee,i=this.codecFor(r);if(!i)throw new Error("unknown content type "+r);let o=i.encode(e,this),a=i.fallback(e);return a&&(o.fallback=a),typeof t?.compression=="number"&&(o.compression=t.compression),await oi(o),content.EncodedContent.encode(o).finish()}async decodeContent(e){let t=content.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let r,i=new $(t.type),o;await si(t,1e3);let a=this.codecFor(i);return a?r=a.decode(t,this):o=new Error("unknown content type "+i),{content:r,contentType:i,error:o,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ke(this.address),async t=>t,e)}async listEnvelopes(e,t,r){r||(r={});let{startTime:i,endTime:o,limit:a}=r,c=await this.apiClient.query({contentTopic:e,startTime:i,endTime:o},{direction:r.direction||messageApi.SortDirection.SORT_DIRECTION_ASCENDING,limit:a}),p=[];for(let l of c)if(l.message)try{let g=await t(l);p.push(g);}catch(g){console.warn("Error in listEnvelopes mapper",g);}return p}listEnvelopesPaginated(e,t,r){return Hr(this.apiClient.queryIteratePages({contentTopic:e,startTime:r?.startTime,endTime:r?.endTime},{direction:r?.direction,pageSize:r?.pageSize||100}),t)}};function No(n){let e=n.apiUrl||mt[n.env];return new Ve(e,{appVersion:n.appVersion})}async function ln(n,e){let t=n.queryIterator({contentTopic:dt(e)},{pageSize:5,direction:he.SORT_DIRECTION_DESCENDING});for await(let r of t){if(!r.message)continue;let i=Dr(r.message),o;try{o=await i?.walletSignatureAddress();}catch{o=void 0;}if(o===e)return i}}async function Ji(n,e){let t=e.map(dt),r=await n.batchQuery(t.map(i=>({contentTopic:i,pageSize:5,direction:he.SORT_DIRECTION_DESCENDING})));return Promise.all(e.map(async(i,o)=>{let a=r[o];if(a){for(let c of a)if(c.message)try{let p=Dr(c.message),l=await p?.walletSignatureAddress();if(i===l)return p;console.info("Received contact bundle with incorrect address");}catch(p){console.info("Invalid contact bundle",p);}}}))}function ji(){return [new Ge,new be,new we]}async function Oo(n,e,t){for(let r of n.keystoreProviders)try{return await r.newKeystore(n,e,t??void 0)}catch(i){if(i instanceof L)continue;throw i}throw new Error("No keystore providers available")}var fn=new $({authorityId:"xmtp.org",typeId:"composite",versionMajor:1,versionMinor:0}),hn=class{get contentType(){return fn}encode(e,t){let r=this.toProto(e,t),i;r.composite?i=r.composite:i={parts:[r]};let o=composite.Composite.encode(i).finish();return {type:fn,parameters:{},content:o}}decode(e,t){return this.fromProto({composite:composite.Composite.decode(e.content),part:void 0},t)}toProto(e,t){if("type"in e){let i=t.codecFor(e.type);if(!i)throw new Error(`missing codec for part type ${e.type}`);return {part:i.encode(e.content,t),composite:void 0}}let r=new Array;for(let i of e.parts)r.push(this.toProto(i,t));return {composite:{parts:r},part:void 0}}fromProto(e,t){if(e.part){if(!e.part.type)throw new Error("missing part content type");let i=new $(e.part.type),o=t.codecFor(i);if(!o)throw new Error(`missing codec for part type ${i}`);return {type:i,content:o.decode(e.part,t)}}if(!e.composite)throw new Error("invalid composite");let r=new Array;for(let i of e.composite.parts)r.push(this.fromProto(i,t));return {parts:r}}fallback(e){}};/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)
*/

export { mt as ApiUrls, Ue as AuthCache, ne as BrowserStoragePersistence, I as Ciphertext, Me as Client, hn as CompositeCodec, Uo as Compression, fn as ContentTypeComposite, As as ContentTypeFallback, $ as ContentTypeId, Ee as ContentTypeText, Q as ConversationV1, ae as ConversationV2, Ne as Conversations, q as DecodedMessage, Fe as EncryptedPersistence, Ve as HttpApiClient, Z as InMemoryKeystore, ve as InMemoryPersistence, we as KeyGeneratorKeystoreProvider, ge as LocalAuthenticator, J as MessageV1, Se as MessageV2, be as NetworkKeystoreProvider, Le as PrefixedPersistence, te as PrivateKey, N as PrivateKeyBundleV1, G as PrivateKeyBundleV2, V as PublicKey, P as PublicKeyBundle, le as SealedInvitation, S as Signature, E as SignedPublicKey, A as SignedPublicKeyBundle, Je as SnapProvider, he as SortDirection, Ge as StaticKeystoreProvider, F as Stream, lt as TextCodec, Re as buildContentTopic, se as buildDirectMessageTopic, pt as buildDirectMessageTopicV2, dt as buildUserContactTopic, de as buildUserIntroTopic, Ke as buildUserInviteTopic, Fr as buildUserPrivateStoreTopic, D as dateToNs, Dr as decodeContactBundle, ks as decodeContent, j as decrypt, ji as defaultKeystoreProviders, ee as encrypt, ss as fromNanoString, wt as keystoreApiDefs, Hr as mapPaginatedStream, _ as nsToDate, Xe as retry, ue as toNanoString };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map